#!/usr/bin/env tsx

import { config } from 'dotenv';
config();

import { promises as fs } from 'fs';
import path from 'path';
import { AxiosHttpClient } from '../src/adapters/output/infrastructure/http/AxiosHttpClient';
import { NotionRepository } from '../src/adapters/output/infrastructure/notion/NotionRepository/NotionRepository';
import { QueryDatabaseUseCase } from '../src/domain/usecases/QueryDatabaseUseCase';
import { GetPageUseCase } from '../src/domain/usecases/GetPageUseCase';
import { GetBlockChildrenRecursiveUseCase } from '../src/domain/usecases/GetBlockChildrenRecursiveUseCase';
import { Page } from '../src/domain/entities/Page';
import { Block } from '../src/domain/entities/Block';
import { convertBlocksToMarkdown } from '../src/utils/blockToMarkdownConverter';

interface PageWithBlocks {
  id: string;
  properties: Record<string, unknown>;
  createdTime?: string;
  lastEditedTime?: string;
  url?: string;
  blocks: Block[];
  blocksStats: {
    totalBlocks: number;
    maxDepthReached: number;
    totalApiCalls: number;
  };
  blocksError?: string;
}

// Funci√≥n helper para extraer el t√≠tulo de una p√°gina
const getPageTitle = (page: Page | PageWithBlocks): string => {
  try {
    const properties = page.properties;
    const titleKeys = ['title', 'Title', 'Name', 'name', 'T√≠tulo'];

    for (const key of titleKeys) {
      if (properties[key]) {
        const prop = properties[key] as {
          title?: { plain_text?: string; text?: { content?: string } }[];
          rich_text?: { plain_text?: string; text?: { content?: string } }[];
        };

        if (prop?.title && Array.isArray(prop.title) && prop.title.length > 0) {
          return prop.title[0]?.plain_text || prop.title[0]?.text?.content || '';
        }
        if (prop?.rich_text && Array.isArray(prop.rich_text) && prop.rich_text.length > 0) {
          return prop.rich_text[0]?.plain_text || prop.rich_text[0]?.text?.content || '';
        }
      }
    }

    return `P√°gina ${page.id.substring(0, 8)}`;
  } catch {
    return `P√°gina ${page.id.substring(0, 8)}`;
  }
};

// Funci√≥n helper para generar la secci√≥n de metadatos
const generateMetadataSection = (page: Page | PageWithBlocks): string => {
  let content = '---\n';
  content += '## üìã Metadatos\n\n';

  content += `**ID de la p√°gina:** \`${page.id}\`\n\n`;

  if (page.url) {
    content += `**URL:** [Ver en Notion](${page.url})\n\n`;
  }

  if (page.createdTime) {
    const createdDate = new Date(page.createdTime).toLocaleString('es-ES');
    content += `**Fecha de creaci√≥n:** ${createdDate}\n\n`;
  }

  if (page.lastEditedTime) {
    const editedDate = new Date(page.lastEditedTime).toLocaleString('es-ES');
    content += `**√öltima modificaci√≥n:** ${editedDate}\n\n`;
  }

  // Si es una PageWithBlocks, a√±adir estad√≠sticas de bloques
  if ('blocksStats' in page) {
    content += `**Estad√≠sticas de bloques:**\n`;
    content += `- Total de bloques: ${page.blocksStats.totalBlocks}\n`;
    content += `- Profundidad m√°xima: ${page.blocksStats.maxDepthReached}\n`;
    content += `- Llamadas API: ${page.blocksStats.totalApiCalls}\n\n`;
  }

  content += '---\n\n';

  return content;
};

// Funci√≥n para crear nombre de archivo seguro
const createSafeFilename = (title: string): string => {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .trim()
    .substring(0, 50) || 'sin-titulo';
};

async function recursiveMarkdownDownload() {
  try {
    console.log('üöÄ Iniciando descarga recursiva de Notion a Markdown...');

    // Verificar variables de entorno
    const notionApiKey = process.env.NOTION_API_KEY || process.env.VITE_NOTION_API_KEY;
    const databaseId = process.env.NOTION_DATABASE_ID || process.env.VITE_NOTION_DATABASE_ID;

    if (!notionApiKey) {
      throw new Error('NOTION_API_KEY o VITE_NOTION_API_KEY no est√° configurado');
    }

    if (!databaseId) {
      throw new Error('NOTION_DATABASE_ID o VITE_NOTION_DATABASE_ID no est√° configurado');
    }

    console.log('‚úÖ Variables de entorno configuradas');

    // Crear instancias
    const baseURL = 'https://api.notion.com/v1';
    const defaultHeaders = {
      'Authorization': `Bearer ${notionApiKey}`,
      'Notion-Version': '2022-06-28'
    };

    const httpClient = new AxiosHttpClient(baseURL, defaultHeaders);
    const notionRepository = new NotionRepository(httpClient);
    const queryDatabaseUseCase = new QueryDatabaseUseCase(notionRepository);
    const getPageUseCase = new GetPageUseCase(notionRepository);
    const getBlockChildrenRecursiveUseCase = new GetBlockChildrenRecursiveUseCase(notionRepository);

    // Crear carpeta de destino
    const markdownDir = path.join(process.cwd(), 'output', 'markdown');
    await fs.mkdir(markdownDir, { recursive: true });

    console.log('üìÅ Carpeta markdown lista:', markdownDir);

    // Paso 1: Obtener p√°ginas de la base de datos
    console.log('üîç Consultando base de datos...');
    const databasePages = await queryDatabaseUseCase.execute(databaseId);

    if (!databasePages || databasePages.length === 0) {
      throw new Error('No se encontraron p√°ginas en la base de datos');
    }

    console.log(`‚úÖ Encontradas ${databasePages.length} p√°ginas`);

    // Paso 2: Obtener contenido completo de cada p√°gina CON bloques recursivos (EN PARALELO)
    console.log('üöÄ Obteniendo p√°ginas completas y bloques recursivos en paralelo...');

    const pagePromises = databasePages.map(async (dbPage) => {
      try {
        const pageTitle = getPageTitle(dbPage);

        // Obtener p√°gina completa
        const fullPage = await getPageUseCase.execute(dbPage.id);

        // Obtener bloques recursivos
        const blocksResult = await getBlockChildrenRecursiveUseCase.execute(fullPage.id, {
          maxDepth: 5,
          includeEmptyBlocks: false,
          delayBetweenRequests: 100 // Reducido porque ahora procesamos en paralelo
        });

        const pageWithBlocks: PageWithBlocks = {
          ...fullPage,
          blocks: blocksResult.blocks,
          blocksStats: {
            totalBlocks: blocksResult.totalBlocks,
            maxDepthReached: blocksResult.maxDepthReached,
            totalApiCalls: blocksResult.apiCallsCount
          }
        };

        console.log(`   ‚úÖ ${pageTitle}: ${blocksResult.totalBlocks} bloques obtenidos (profundidad: ${blocksResult.maxDepthReached})`);

        return { success: true, page: pageWithBlocks, error: null };
      } catch (pageError) {
        const pageTitle = getPageTitle(dbPage);
        const errorMsg = `Error en p√°gina ${pageTitle} (${dbPage.id}): ${pageError instanceof Error ? pageError.message : 'Error desconocido'}`;
        console.error(`‚ùå ${errorMsg}`);
        return { success: false, page: null, error: errorMsg };
      }
    });

    // Ejecutar todas las promesas en paralelo
    const results = await Promise.all(pagePromises);

    // Procesar resultados
    const pagesWithBlocks: PageWithBlocks[] = [];
    const errors: string[] = [];
    let totalBlocks = 0;
    let totalApiCalls = 0;

    results.forEach(result => {
      if (result.success && result.page) {
        pagesWithBlocks.push(result.page);
        totalBlocks += result.page.blocksStats.totalBlocks;
        totalApiCalls += result.page.blocksStats.totalApiCalls;
      } else if (result.error) {
        errors.push(result.error);
      }
    });

    console.log(`‚úÖ Procesadas ${pagesWithBlocks.length}/${databasePages.length} p√°ginas`);
    console.log(`üìä Total de bloques obtenidos: ${totalBlocks}`);
    console.log(`üîÑ Total de llamadas API: ${totalApiCalls}`);

    // Paso 3: Convertir a Markdown con bloques recursivos
    console.log('üìù Convirtiendo p√°ginas a Markdown con contenido recursivo...');

    const markdownFiles: Array<{ filename: string; content: string }> = [];

    for (const pageWithBlocks of pagesWithBlocks) {
      const title = getPageTitle(pageWithBlocks);
      const filename = `${createSafeFilename(title)}.md`;

      // Crear contenido Markdown
      let content = `# ${title}\n\n`;

      // Agregar secci√≥n de metadatos
      content += generateMetadataSection(pageWithBlocks);

      // Agregar contenido de bloques
      if (pageWithBlocks.blocks.length > 0) {
        content += `## Contenido\n\n`;
        content += convertBlocksToMarkdown(pageWithBlocks.blocks);
      } else {
        content += `*Esta p√°gina no tiene contenido de bloques.*\n\n`;
      }

      // Agregar informaci√≥n de error si existe
      if (pageWithBlocks.blocksError) {
        content += `\n---\n**Error en bloques:** ${pageWithBlocks.blocksError}\n`;
      }

      markdownFiles.push({ filename, content });
    }

    // Crear archivo √≠ndice mejorado
    const indexContent = `# √çndice de P√°ginas (Contenido Recursivo)\n\n`;
    let indexBody = `**Resumen:**\n`;
    indexBody += `- Total de p√°ginas: ${pagesWithBlocks.length}\n`;
    indexBody += `- Total de bloques: ${totalBlocks}\n`;
    indexBody += `- Total de llamadas API: ${totalApiCalls}\n`;
    indexBody += `- Promedio de bloques por p√°gina: ${Math.round(totalBlocks / pagesWithBlocks.length * 100) / 100}\n\n`;

    indexBody += `## P√°ginas\n\n`;

    for (const pageWithBlocks of pagesWithBlocks) {
      const title = getPageTitle(pageWithBlocks);
      const filename = `${createSafeFilename(title)}.md`;
      indexBody += `- [${title}](${filename}) `;
      indexBody += `*(${pageWithBlocks.blocksStats.totalBlocks} bloques, profundidad ${pageWithBlocks.blocksStats.maxDepthReached})*\n`;
    }

    if (errors.length > 0) {
      indexBody += `\n## Errores\n\n`;
      errors.forEach(error => {
        indexBody += `- ${error}\n`;
      });
    }

    const indexFile = { filename: 'index.md', content: indexContent + indexBody };

    // Paso 4: Guardar archivos
    console.log('üíæ Guardando archivos...');

    // Guardar √≠ndice
    await fs.writeFile(
      path.join(markdownDir, indexFile.filename),
      indexFile.content,
      'utf8'
    );
    console.log(`‚úÖ Guardado: ${indexFile.filename}`);

    // Guardar p√°ginas individuales
    for (const markdownFile of markdownFiles) {
      await fs.writeFile(
        path.join(markdownDir, markdownFile.filename),
        markdownFile.content,
        'utf8'
      );
      console.log(`‚úÖ Guardado: ${markdownFile.filename}`);
    }

    // Resumen final
    console.log('\nüéâ ¬°Conversi√≥n recursiva completada!');
    console.log(`üìÅ Ubicaci√≥n: ${markdownDir}`);
    console.log(`üìÑ Archivos creados: ${markdownFiles.length + 1} (${markdownFiles.length} p√°ginas + √≠ndice)`);
    console.log(`‚úÖ P√°ginas procesadas: ${pagesWithBlocks.length}/${databasePages.length}`);
    console.log(`üìä Bloques totales procesados: ${totalBlocks}`);
    console.log(`üîÑ Llamadas API realizadas: ${totalApiCalls}`);

    if (errors.length > 0) {
      console.log(`‚ö†Ô∏è  Errores: ${errors.length}`);
      errors.forEach(error => console.log(`   - ${error}`));
    }

    console.log('\nüìù Archivos Markdown con contenido recursivo guardados en output/markdown/');
  } catch (error) {
    console.error('‚ùå Error en conversi√≥n recursiva:', error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

// Ejecutar si se llama directamente
if (import.meta.url === `file://${process.argv[1]}`) {
  recursiveMarkdownDownload();
}

export { recursiveMarkdownDownload }; 